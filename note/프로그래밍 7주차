1. 객체 배열
          -객체배열 생성 및 사용

          -생성 및 초기화 과정
              Circle[] c;  //객체 배열 선언

              c = new Circle[5]; //객체 레퍼런스 배열 생성

              for(int i = 0; i < c.length ; i++)
                  c[i] = new Circle(i); //객체 배열 초기화



2. 메소드 형식
          -클래스의 멤버 함수, C/C++의 함수와 동일 하다
          -자바의 모든 메소드는 반드시 클래스 안에 있어야 하는데 이는 캡슐화의 원칙을 지키기 위함이다.

          -메소드 구성 형식
                .1.접근지정자 :public, private, protected, default(접근 지정자가 생략된 경우이다)
                .2.반환타입 :

3.자바의 인자 전달 방식

          -1. 기본타입의 값 전달 (매개변수가 byte, int, double 등 기본타입을 말함)
                값이 복사되어 전달된다.
                메소드의 매개변수가 변경되어도 호출 실인자 값은 변경되지 않는다.

          -2. 객체 혹은 배열의 전달
                객체나 배열의 레퍼런스만 전달한다.
                즉, 객체 혹은 배열이 통째로 복사되어 전달되는 것이아니고
                레퍼런스만을 공유하기 때문에 ... (두개의 레퍼런스 변수가 같은 객체를 가리킬수 있는것임)
                메소드의 매개변수와 호출한 실인자 객체나 배열을 공유한다.

          -3. 인자전달 - 배열이 전달되는 경우
                배열 통째로 전달되지 않는다.
                이는 객체가 전달되는 경우와 동일하며
                매개변수가 실인자의 배열을 공유한다.


4.메소드 오버로딩
          :이름이 같은 메소드를 작성하는 것이다.
              단, 매개변수의 개수나 타입이 서로 다르고
              이름만 동일한 메소드를 말한다.
              여기서 , return 타입은 오버로딩과 관련이 없다.

              매개변수의 개수와 타입이 같으면서 이름까지 같은 메소드를 만들면
              오버로딩이 아닌 같은 메소드로 인식하기 때문에
              당연히 오류가 난다.


5.객체의 소멸과 가비지 컬렉션
          객체 소멸 : new에 의해 할당된 객체 메모리를 자바 가상 머신의 가용 메모리로 되돌려주는 행위....
                    -자바 응용프로그램에서 임의로 객체소멸을 할수는 없다.
                     (C나 C++은 할당 받은 객체를 개발자가 되돌려줘야 한다는 점에서 다르다. )

          가비지 : 가리키는 레퍼런스가 하나도 없는 객체
          가비지 컬렉션 : JVM의 가비지 컬렉터가 자동으로 가비지를 수집 반환함


          -개발자에 의한 강제 가비지 컬렉션 (not객체소멸)
                :System.gc();  // 가비지 컬렉션 작동 요청
                                그러나 이렇게 요청해도 JVM이 가비지컬렉션 시점을 전적으로 판단한다.



6.자바의 패키지 개념
          -패키지 : 관련있는 클래스 파일을 저장하는 디렉터리이다.
                    자바 응용프로그램은 하나 이상의 패키지로 구성된다.

7.자바의 접근 지정자
          - 4가지 : private, protectedm public, dedault(생략)  //이는 패키지 단위로 범위가 결정된다.

          - 접근 지정자의 목적:
                클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용하는것이다.
                객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것이기 때문이다.
                즉, 접근 지정은 캡슐화에 묶인 보호를 일부 해제하기 위함 이다.


          -public class : 다른 모든 클래스에게 접근 허용한다. 이는 패키지에관련이 없다.
          -dafault class  : package-private이라고도 하는데 같은 패키지의 클래스에만 접근을 허용한다. 즉, 다른 패키지의 접근은 불허한다.

          -public member : 패키지에 관계없이 모든 클래스에게 접근 허용
          -private member : 동일 클래스 내에만 접근을 허용한다.
                            상속 받은 서브 클래스에서 접근이 불가능하다.
          -protected member : 같은 패키지 내의 다른 모든 클래스에게 접근 허용된다.
                              상속 받은 서브 클래스는 다른 패키지에 있어도 접근이 가능하다.
                              상속을 한 클래스가 아니라 상속을 "받은" 클래스가 상속해준 클래스에 접근이 가능한것이다.

          -default member : 같은 패키지 내의 다른 클래스에게 접근을 허용한다.


8.static에 대한 이해
                : static은 모두가 공유하는것으로 이해할수 있다.

                - non-static 멤버의 특성
                        : 멤버들은 객체마다 독립적으로 존재하며
                          필드와 메소드는 객체 생성후에야 사용가능하다.
                          또한 멤버들은 다른 객체에 의해 공유되지 않고 배타적이다.


                - static 멤버의 특성
                        : 이는 객체마다 생성되는 non_static멤버와는 다르므로 class 멤버라고도 한다.
                          - 그래서 클래스당 하나만 생성되며
                                객체 생성없이 사용이 가능하다.
                          - 이는 클래스가 로딩될때 공간을 할당받으며 클래스당 하나만 생성된다.( 객체 내부가 아닌 클래스 코드가 적재되는
                                메모리에 생성된다. )
                          - static 멤버들은 동일한 클래스의 모든 객체에 의해 공유된다.

                - static 멤버를 클래스 이름으로 접근하는 경우
                        :
